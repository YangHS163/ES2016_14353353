#Cause of the DeadLock

产生死锁的主要原因有以下三点：
1.系统资源不足；
2.进程运行推进的顺序不合理；
3.资源分配不当。
加入系统资源非常充足，进程的资源请求都能获得满足，那么产生死锁的概率就会非常低，否则就有可能因为资源冲突而发生死锁；

#Four necessary conditions of DeadLock
1.互斥条件： 一份资源在同一时间只能被一个进程使用
2.请求与保持条件： 如果一个进程因为请求资源而被阻塞时，对已经占有的资源保持不放
3.不剥夺条件： 进程已获得的资源，在未使用完之前，不能强行剥夺
4.循环等待条件： 进程之间形成头尾相接的循环等待关系，比如A请求B的资源而B又请求A的资源

四个条件均满足就会发生死锁，如果有一个不满足就会破解死锁。

#The Screenshots of DeadLock

![image5](https://github.com/YangHS163/ES2016_14353353/blob/master/deadlock.png)

#The explanation of DeadLock

首先看看deadlock.java文件，文件中有两个类A、B，每一个里面均有两个函数，分别为last和methodA(或methodB);
这四个函数均为synchronized类型，也就是说同一时刻，只能有一个线程在访问对象的synchronized同步代码块，其他线程对对象中所有其他synchronized同步代码块的访问将被阻塞；
在类Deadlock中，分别声明了一个A类和B类，然后值声明了一个线程，倒数一定时间后开始调用a的methodA函数去请求进入b的地盘；
这时我们再看看deadlock中的run函数，其中有调用b的methodB函数去请求进入A的地盘，而由于Deadlock是Runnable类型，这就表明每次调度deadlock的时候，它都会运行run()中的语句，也就是说run中的内容不一定在a.methodA之后；
所以在t.start之后，也就是线程开始工作之后，a、b两条路线基本是一齐开始：a在while循环结束之后开始，而b由于在run()之中，其开始条件与while无关；
最后再来看看test.sh中代码，其中就是调用deadlock.java这份代码c次（c的值为多少由我们自己定义），而由于a和b的函数调用没有明确的先后关系，这就导致了很有可能它俩同时被调用，然后这时就会满足四个产生死锁的条件：
1.互斥条件，由于synchronized代码段一次只能有一个线程在运行，基本上同时只有A或者B一个对象能调用自己的函数，满足条件；
2.请求与保持条件，在两个类之中，并没有特别申明有对资源的释放，并且当线程进入一个synchronized代码段中的函数时，基本只有把它全部执行完毕才能出来，所以资源的保留条件满足；
3.不剥夺条件：由于代码中没有抢占调度这一部分的实现，所以不会发生抢占，并且，当线程t进入A或者B的synchronized代码段中时，就已经没有别的线程去调用另一个对象的synchronized代码段中的函数了，更加不可能发生抢占，所以这部分满足；
4.循环等待条件，这个只有在二者同时调用自己的method函数时发生，因为这时A在等B，B在等A，满足条件。
综上所述，在调用deadlock.java足够多次时，总有一次会满足第四个条件然后发生死锁，但是由于run()这部分我们没有办法掌握它启动的时间，所以就需要启用一个足够大的循环来多次调用deadlock.java。
所以这就是我对本次实验中死锁产生的理解。
